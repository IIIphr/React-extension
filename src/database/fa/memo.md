# memo

### `memo(Component: کامپوننت, arePropsEqual?: آیا_ویژگی‌ها_برابرند؟)`

::: rtl
یک کامپوننت را در `memo` بپیچانید (wrap) تا یک نسخه‌ی به یاد سپرده شده (memoized) از این کامپوننت داشته باشید. این نسخه‌ی به یاد سپرده شده از کامپوننت شما، معمولا زمانی که کامپوننت‌های والدش (parent) بازنمایی می‌شوند (re-render)، تا زمانی که ویژگی‌هایش (props) تغییر نکرده اند، بازنمایی نخواهد شد. اما این رفتار قطعی نیست و ری‌اکت ممکن است همچنان این کامپوننت شما را بازنمایی کند. به یاد سپاری (memoization) روشی برای بهینه سازی بازدهی (peroformance optimization) است و یک تضمین نیست.
:::

``` jsx
import { memo } from 'react';

const SomeComponent = memo(function SomeComponent(props) {
  // ...
});
```

::: rtl
### پارامترها

* `Component: کامپوننت`: کامپوننتی است که می‌خواهید به یاد سپرده شود. `memo` این کامپوننت را تغییر نمی‌دهد، اما به جای آن یک کامپوننت به یاد سپرده شده‌ی جدید برمی‌گرداند. هر کامپوننت معتبر (valid) ری‌اکت (خواه تابع باشد یا `forwardRef`)، قابل قبول است.

* (اختیاری) `arePropsEqual: آیا_ویژگی‌ها_برابرند`: تابعی است که دو آرگومان قبول می‌کند: ویژگی‌های قبلی کامپوننت، و ویژگی‌های جدیدش. این تابع باید در صورت برابری ویژگی‌های فدیمی و جدید `true` برگرداند. برابری به این معنی است که در هر دو حالت، کامپوننت خروجی یکسانی نمایش خواهد داد و رفتار یکسانی خواهد داشت. در غیر این صورت، ابن تایع باید `false` برگرداند. معمولا نیازی به تعریف این تابع توسط شما نیست. به صورت پیش‌فرض، ری‌اکت هر ویژگی را با استفاده از `Object.is` مقایسه می‌کند.

### خروجی

`memo` یک کامپوننت جدید ری‌اکت برمی‌گرداند. این کامپوننت جدید دقیقا مانند کامپوننتی که به عنوان ورودی به `memo` می‌دهید عمل می‌کند، به جز اینکه زمانی که کامپوننت والدش بازنمایی می‌شود، ری‌اکت همیشه آن را بازنمایی نخواهد کرد.
:::

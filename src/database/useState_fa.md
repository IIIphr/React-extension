# useState

### `useState(وضعیت اولیه)`

::: rtl
تابع `useState` را برای تعریف یک متغیر حالت (state variable) در بالاترین لایه‌ی کامپوننت (component) خود صدا بزنید.
:::

``` js
import { useState } from 'react';
function MyComponent() {
	const [age, setAge] = useState(28);
	const [name, setName] = useState('Taylor');
	const [todos, setTodos] = useState(() => createTodos());
	// ...
```

::: rtl
بهتر است متغیر حالت خود را با استفاده از جداسازی آرایه‌ای (array deconstructing) به شکل `[name, setname]` نامگذاری کنید.

مثال‌های بیشتری در ادامه خواهیم آورد.

### پارامترها

* `initialState`: مقداری که می‌خواهید متغیر حالت شما در ابتدا داشته باشد. این مقدار می‌تواند از هر جنسی باشد، ولی در صورت استفاده از توابع، رفتار خاصی انجام خواهد شد. به این آرگومان بعد از نمایش (render) اولیه توجهی نخواهد شد.

	* اگر به جای `initialState` یک تابع قرار دهید، با این تابع به عنوان یک تابع مقدار دهی اولیه (initializer function) رفتار خواهد شد. این تابع باید مطلق (pure) باشد، هیچ آرگومانی نگیرد و باید یک مقدار (از هر نوعی) برگردارند. ری‌اکت تابع مقدار دهی اولیه‌ی شما را زمانی که کامپوننت را برای اولین بار راه اندازی می‌کند (initializing) فراخوانی می‌کند، و مقدار خروجی آن را به عنوان وضعیت اولیه نگهداری می‌کند. یک مثال از پایین مشاهده کنید.

### خروجی تابع

`useState` یک آرایه با دقیقا دو عضو برمی‌گرداند:

1. وضعیت فعلی. در نمایش اولیه، این مقدار برابر است با `initialState` ای که شما به آن تحویل (pass) داده اید.

2. تابع مقدار دهی‌ای (`set` function) که به شما امکان به روز رسانی متغیر وضعیت را خواهد داد، و باعث یک بازنمایش (re-render) خواهد شد.

### هشدارها

* `useState` یک قلاب (Hook) است، در نتیجه شما فقط می‌توانید آن را در بالاترین لایه از کامپوننت یا قلاب خود صدا بزنید. شما نمی‌توانید قلاب‌ها را در حلقه‌ها یا شروط صدا بزنید. اگر نیاز به چنین استفاده‌هایی دارید، یک کامپوننت دیگر استخراج کنید و این وضعیت (state) را به کامپوننت جدید منتقل کنید.

* در حالت سخت‌گیرانه (strict mode)، React تابع مقدار دهی اولیه‌ی شما را دو بار فراخوانی می‌کند تا شما بتوانید ناخالصی‌های تصادفی (accidental impurities) را پیدا کنید. این رفتار صرفا محدود به فضای توسعه (development-only behavior) است و تأثیری روی برنامه‌ی تولیدی نهایی (production) ندارد. اگر تابع مقدار دهی اولیه‌ی شما خالص است (همانطور که باید باشد)، این ویژگی رفتار برنامه‌ی شما را تغییر نخواهد داد. از نتایج یکی از این دو بار فراخوانی توابع چشم پوشی می‌شود.
:::